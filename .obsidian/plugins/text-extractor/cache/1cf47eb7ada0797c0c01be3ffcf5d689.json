{"path":"Files/Ling 430 - Handout #6 - Stemming.pdf","text":"Ling 430 February 2 nd, 2022 Stemming and Lemmatization 1. Document Semantics, cont’d Remember that we are trying to characterize a text or document in terms of what words commonly occur in it. “Today, John ran for six miles, then continued running. He is an avid runner who likes to run a lot, and also likes swimming.” Tally up the counts for the unique words in this short text. Does the highest count seem to be the best “topic” descriptor of this text? What might be the best topic, and why isn’t this accurately captured? 2. Stemming • Stemming is another means of text normalization which isolates the stem of each word such that all words with the same stem are treated the same. Thus, we want: run → run running → run runs → run • Stemmers are often built on regular expressions that are written to match and return the stem without any affixes. Example for ‘plural’ form stemming below: words = [‘cat’, ‘cats’, ‘dog’, ‘dogs’, ‘house’, ‘houses’] stems = [] for word in words: stem = re.findall(r‘^(.*?)s?$’, word) stems.append(stem[0]) (or the last four lines as a list comprehension): stems = [re.findall(r’^(.*?)s?$’, word)[0] for word in words] How do we interpret the regular expression here? • Note that parentheses, ( ), not only group items, but form capture groups- -- so we get a matching string for (.*?), which is captured, and then it looks for an optional s?$. The output of re.findall will be a list containing a single match • (.*?) is the lazy * operator; if it were greedy, it would always include the final ‘s’ as well and not let the suffix match on that Exercise: Extend the regular expression to correctly extract the stem for the following word list: words = [‘cat’, ‘cats’, ‘dog’, ‘dogs’, ‘house’, ‘houses’, ‘dish’, ‘dishes’, ‘church,’ ‘churches’, ‘maze’, ‘mazes’] But you’ll probably want to use something called a lookahead or lookbehind: x(?=y) (positive) lookahead: only match x if followed by y x(?!y) negative lookahead: only match x if it is not followed by y (?<=y)x (positive) lookbehind: only match x if preceded by y (?<!y)x negative lookbehind: only match x if not preceded by y Note: For all of these, whatever y is, it will not be returned, while x will, i.g,. this is different from (xy)? Also: you may want to use some non-capturing parentheses for this, so you can group things you don’t want returned: (?: ) What additional words would be problematic for our plural stemmer?’ • Fortunately, there are some stemmers available for us to use: 1) Porter Stemmer: from nltk.stem.porter import PorterStemmer stemmer = PorterStemmer() stems = [stemmer.stem(word) for word in words] 2) Lancaster Stemmer: from nltk.stem.lancaster import LancasterStemmer stemmer = LancasterStemmer() stems = [stemmer.stem(word) for word in words] Try these two stemmers out on our example words, and add more tricky -s plurals to see how they handle them. 3. Lemmatization • Lemmatization is similar to stemming but a bit more advanced: a) The lemma of a word is always a real word b) A word’s lemma may not look like the word c) Lemmatization can involve more than just chopping off ending Lemma examples: played > play happiness > happy better > good were > be • NLTK’s WordNet Lemmatizer: import nltk lemmatizer = nltk.WordNetLemmatizer() lemmas = [lemmatizer.lemmatize(word) for word in words] • The WordNet Lemmatizer also takes part of speech into account, and by default assumes words are nouns. Try the following: lemmatizer.lemmatize(“are”) lemmatizer.lemmatize(“are”, pos = “v”)","libVersion":"0.5.0","langs":""}