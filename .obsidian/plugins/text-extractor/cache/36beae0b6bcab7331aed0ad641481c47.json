{"path":"Files/Ling 430 - Handout #3 - Regular Expressions.pdf","text":"Ling 430 January 24 th, 2022 Regular Expressions 1. Regular Expressions • Consider that you want to search a text or corpus for some very specific word patterns. Perhaps you want to find all the words that start with a vowel, end a consonant followed by an ‘h,’ and are a total of 6-8 characters long. How would you program this with our current knowledge? • Regular expressions provide a simpler way of doing this. A regular expression is a system of notation for match certain patterns that occur in strings of text. 2. Basic RE patterns: Character matching and word boundaries • Starting simple: let’s find the words ending in ‘es’ in the following sentence: word_list = [‘John’, ‘sees’, ‘the’, ‘houses’, ‘as’, ‘he’, ‘passes’, ‘by’] • We’ll need to import the re library and use the re.search method, specifying the pattern we want to match Basic RE characters: character or operator behavior most alphanumeric characters, say ‘abc’ or ‘123’ will match that alphanumeric character when found in the text; in this case, every instance of ‘abc’ or ‘123’ in the text ^abc matches pattern (in this case ‘abc’) occurring at the beginning of a word abc$ matches pattern (in this case ‘abc’) occurring at the end of a word . matches any single character • Use the method re.search(r‘pattern’, text). The ‘r’ before the string means it’s a raw string, telling Python not to try to interpret anything inside it. We can have it return the truth value (did it match or not?) for this simple example: bool(re.search(r‘es$’, ‘sees’) • But now let’s write a function that returns a list of all the words in word_list that match our RE pattern. A list comprehension will work well here: match_words = [word for word in word_list if re.search(r‘es$’, word)] Exercise: 1) Scale up: apply your function to an NLTK text. 2) Write the following RE patterns: a) match all words starting with ‘x’ b) match all words starting with ‘d’ and ending in ‘t’ that are 5 letters long 3. Options and conditions in RE patterns • We may want to introduce some options or additional conditions into our pattern: Sets of possible characters for a given position can be indicated with square brackets e.g., ‘^[abc]’ will match any word beginning with either ‘a,’ ‘b,’ or ‘c’ Similarly, a range matches any value in that range: e.g., ‘^[a-z]’ will match any word beginning with ‘a’, ‘b,’ ‘c,’ ‘d,’ etc. The ‘^’ operator inside [ ] will indicate the complementary set, i.e., elements not in that range: e.g., ‘a[^a-z]’ would match on a sequence of ‘a’ followed by anything other than a-z, e.g., ‘a1,’ ‘a#’ or ‘aA’ • We might also want to indicate that a variable number of some element is allowable for a match: (i) ‘*’ will indicate the string must match zero or more of the previous element (called a Kleene closure): e.g.: ‘a[aeiou]*’ will match any vowel sequence starting with ‘a’ (ii) ‘+’ matches on one or more of the previous element (regular closure): e.g.: ‘a[aeiou]+’ will match any vowel sequence starting with ‘a’ that is at least two vowels long (iii) ‘?’ matches on zero or one of the previous element, i.e., it’s optional: e.g., ‘aa?’ will match ‘a’ or ‘aa’ (but not ‘b’) • You can also indicate how many repeats of the previous element you want: operator behavior {n} matches if previous element repeated exactly n times {n,} matches if previous element repeated at least n times {,n} matches if previous element repeated no more than n times {m,n} matches if previous element repeated at least m and no more than n times • Lastly, you can indicate a disjunction--- matching one thing or the other--- with the ‘|’ operator: e.g., ‘cat|dog’ will match ‘cat’ or ‘dog’ 4. Grouping, precedence, and greediness • Thinking about the ‘cat|dog’ example above, what strings do you think will match the pattern ‘bunny|ies’? • Sequences, like ‘bunny’ or ‘ies’ are said to have precedence over disjunction, or the ‘|’ operator. • If we want to make sure the choice is between ‘y’ and ‘ies’ and not ‘bunny’ and ‘ies,’ we need to group the ‘y’ and ‘ies’ together using the parentheses operator: ‘bunn(y|ies)’ • Precedence hierarchy, from highest to lowest: Parentheses ( ) Counters * + ? { } Sequences and anchors abc ^abc$ Disjunction | • Compare the results of ‘ab|cd’ vs. ‘ab{2,}cd’: Does |, having lower precedence than sequences, apply to ‘ab’ vs. ‘cd’ or ‘b’ vs. ‘c’? Does {2,}, having higher precedence than sequences, apply only to ‘b’ or to ‘ab’? How would we make {2,} apply to ‘ab’? • Now consider a regular expression like ‘[a-z]*’ . We will agree that it will find a match in a string like “abc123”. But what do you think is the matching string in this word? “a” or “abc”? • Most RE operators are greedy, so they will match as much of the string as they can. To indicate a non-greedy or lazy operator, place a ? after it. Thus we can convert the greedy operators * , + , and ? to lazy ones: *? , +? , and ??. • ‘[a-z]*?’ would only match “a” within “abc123” 5. Escape characters • We can use the ‘\\’ operator to indicate an alternate usage of a particular character. This will convert operators into actual character: e.g. ‘\\*’, ‘\\+’, ‘\\?,’ ‘\\.’ will match on the actual characters ‘*’, ‘+’, ‘?’, and ‘.’ respectively • This also yields different uses for some regular characters: \\n newline \\t tab \\r carriage return 6. Alterative range operators • The table below shows some alternative ways to indicate commonly used ranges and groups of characters: RE equivalent expression matches \\d [0-9] any digit \\D [^0-9] any non-digit \\w [a-zA-Z0-9_] any alphanumeric or underscore \\W [^\\w] any non-alphanumeric character \\s [ \\r\\t\\n\\f] whitespace (including tabs, etc.) \\S [^\\s] Non-whitespace 7. Re Methods i. re.compile(pattern) This assigns a regular expression to a variable: pattern = re.compile(r‘^[a].*’ ii. re.search(pattern, string) OR pattern.search(string) Returns a Match object (bool True) if the pattern occurs anywhere in the string, or None if there is no match in the string (bool False). iii. re.match(pattern, string) OR pattern.match(string) Returns a Match object (bool True) if the patterns occurs at the beginning of the string, or None if not (bool False). iv. re.findall(pattern, string) OR pattern.findall(string) Returns a list of all the matches to the pattern in the particular string, e.g.: print (re.findall(r’a.e’, “Jake came and played a game late last night.”) returns: [‘ake’, ‘ame’, ‘aye’, ‘ame’, ‘ate’] Exercises: 1) When chatting online, people often lengthen words for emphasis or to convey expression without intonation. Using the Web and Chat Text corpus (webtext), return all versions of ‘hello’: ‘hello’, ‘hhhhhello’, ‘hellooooo’, ‘hhhheeellloo’ etc. Also make sure the pattern matches even if there are final punctuation marks (., !, ? in particular). 2) In a text of your choosing, return all the strings of 3 or more consonant letters. Next, try to pipe this into a NLTK FreqDist object, resulting in the frequencies of different consonant strings in English words.","libVersion":"0.5.0","langs":""}