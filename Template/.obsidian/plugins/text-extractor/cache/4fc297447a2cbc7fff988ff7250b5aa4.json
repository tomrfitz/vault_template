{"path":"Files/Ling 430 - Handout #1 - Review of Python.pdf","text":"Ling 430 January 10 th – 14th , 2022 Handout #1 Review of Python3 1. Assigning variables and basic variable types • You can give a variable (almost) any name • The assignment operator: = • Basic data types: str (string) : assign text to a variable int (integer) : assign number without decimal to a variable float (floating point number): assign a number with a decimal bool (Boolean): assign truth value to variable • The syntax of the variable assignment provides the variable with its type: word = “hello” (string: use parentheses) cycles = 10 (int: number w/o decimal point) frequency = 55.7 (float: number w/ decimal point) completed = True (bool: assign True or False) • You can also assign the value of a pre-existing variable to new variable: new_word = word What data type do you think new_word is with this assignment? • Check a variable’s data type with the function type() • Convert a variable’s type (called casting) with the following functions: str(), int(), float() • Explore: Explain what is happening in the following examples: num = float(4) var = str(763.2) cycles = 82.5 full_cycles = int(cycles) value = int(“hello”) 2. Changing values of variables • We can change values of pre-existing variables Arithmetic operators: + (addition), - (subtraction), * (multiplication), / (division), % (modulo, gives remainder), ** (exponent) • You can also reassign a pre-existing variable What is the value of the variable in the following operations? num = 3 * 7 name = “Jonathan ” + “Manker” a = 3.4 + 9.12 x = 3, y = 2 ** x b = 7 % 2 character = “Major ” * 4 More assignment operators: Combine an arithmetic operator with “=” for an assignment + arithmetic shorthand. E.g.: num = 4 num += 1 #equivalent to: num = num + 1 now num = 5 What values would result below? a = 10 name = “Jonathan ” a /= 2 name += “Manker” 3. Conditions (if-then statements) • If-then statements execute certain code under certain conditions. General structure: if condition 1 : (then) elif condition 2 : #if the first condition isn’t met, then perhaps #2 is (then) else: #if none of the conditions above are met, then… … • Comparison operators: == (equal to), > (greater than), < (less than), >= (greater than or equal), <= (less than or equal), != (does not equal) • Logical operators: and (two conditions met), or (one of two conditions met), not (condition not met) Tips: - Don’t forget to indent. Indentation has a function in Python. - Don’t forget the colon - Don’t forget two equal signs for a conditional == (as opposed to one = which assigns a value) Interpret the following if-then statement: if age == 0: category = “newborn” elif age >= 1 and age < 4: category = “toddler” elif age >= 4 and age < 13: category = “child” elif age >= 13 and age < 18: category = “teenager” else: category = “adult” if manner == “fricative”: if place == “alveolar” or place == “postalveolar”: sibilant = True else: sibilant = False Practice: Write a short Python script that takes an English verb root and produces its past tense and progressive forms (in spelling). It (obviously) does not need to handle all English verbs, but make sure it can handle a few irregular verbs and ones that follow a default pattern. 4. Loops • Loops allow us to perform operations any number of times We can loop over a sequence of numbers with the range() function: num = 10 for x in range(5): num += 5 print (x) • Notice x begins at 0 and ends at 4, increasing by one each time • We can specify the beginning, end, and step of range: range(beginning, end, step) #if only one value is given, range is 0 to that value) So what will be output with this code? for x in range(7, 25, 5): print (x) • We can also nest loops: for x in range(10): for y in range(5): print (x * y) • The while loop keeps looping until the condition is not met: x = 0 while x < 10: print (“Hurray!”) x += 1 5. Collections of data (lists, dictionaries, etc.) i. Lists • A list stores a collection of data in a single variable, indicated with square brackets. Data is ordered, changeable, and duplicate values are allowed. verbs = [“run”, “play”, “sing”] • Add new data to a list with the append method: verbs.append(“dance”) • Remove an item: verbs.remove(“play”) • Lists can store any data type: ages = [5, 7, 12, 52, 7, 26, 33] frequencies = [300.6, 314.8, 307.2] age_by_class = [[12, 13, 12, 12, 13], [12, 12, 12, 13, 13], [12, 13, 13]] attributes = [True, 55.6, “linguistics”] • Items in a list are indexed with numbers starting with 0. We can also refer to how far an item is from the end of a list with a negative number. What do we get with the following? attributes[1] age_by_class[0] ages[-2] • We can take a slice of a list by indicated the beginning and (non-inclusive) end index: What would the variable contain? ages[3:6] ages[2:] #any guesses on these last two? ages[:5] ii. Tuples • Tuples are very similar to lists, but are immutable. Defined with parentheses: verbs = (“run”, “play”, “sing”) • Lists are more commonly used than tuples, but there are some specific advantages and uses for tuples iii. Sets • Sets are unordered, immutable after their creation (the values, though new items can be added or removed), and cannot contain duplicates. This is useful for when collecting a fixed number of possible categories. word_classes = {“verb”, “noun”, “adjective”, “adverb”, “preposition”, “classifier”} word_classes.add(“pronoun”) #adds to set word_classes.remove(“classifier”) #removes from set iv. Dictionaries • Dictionaries are like lists except the values they store are indexed with keys • student_ages = {“steve” : 16, “ashley” : 14, “matt” : 17} print (student_ages[“steve”]) student_ages[“emily”] = 16 v. Iterating • The above data types are all iterable, as well as str (strings). This means we can examine its elements within a for loop. We also use the in operator to examine their contents: verbs = [“see”, “hear”, “sleep”, “stand”, “run”, “dance”, “sing”] for item in verbs: print (item) What will happen below? verbs = [“see”, “hear”, “sleep”, “stand”, “run”, “dance”, “sing”] for letter in verbs[2]: print (letter) We can have multiple indices when we refer to sequences inside of other sequences. What results from the code below? print (verbs[2][3]) • Note the in function can also be used in if-then statements: verbs1 = [“play”, “wait”, “turn”, “fold”] verbs2 = [“hate”, “love”, “move”, “bake”, “believe”] if word in verbs1: verb_past = word + “ed” elif word in verbs2: verb_past = word + “d” else: print (“Verb is not in database!”) Practice: Try to improve your verb past tense generator program from before. There are many ways you can improve this program using lists and dictionaries. Make sure you have a default rule, but also try to think of better ways to encode generalized rule exceptions (like the -ed/d choice above). 6. Functions • Functions are blocks of code that perform a particular task • They can require a certain number of parameters (variables) or arguments (the values of the variables) that they manipulate, then they return some information • Built-in functions we’ve already used: range(), print(), str(), etc. • A few more useful built-in functions: len(x) --- returns the length of a sequence (lists, strings, etc.) or collection (dictionaries, sets, etc.) max(iterable) and min(iterable) --- give the maximum or minimum value of an iterable But you can also write your own function: def past_tense(verb): #function is called “past_tense” and it takes one argument, “verb” form = verb + “ed” return form help_past = past_tense(“help”) • Functions are useful because: 1) They can be reused whenever needed in a program 2) They help organize your code, dividing it into individual tasks Observe the usefulness of the function below: verb_pst = {} verbs = [“help”, “wait”, “learn”, “fold”, “turn”] for item in verbs: verb_pst[item] = past_tense(verb) 7. Objects and classes • An object is a broad term for basically any entity in a program that may have its own attributes and methods • A class defines a certain type of object • Attributes are values associated with a particular class • Methods are functions associated with a particular class • We’ve already seen some built-in classes, like any data-types: list = [“noun”, “verb”, “adjective”] #a list is an object list.append(“adverb”) # “append” here is a method that applies to a list • You can create your own classes with associated methods and attributes, but it’s not something we’ll need to do for this course (but we’ll be importing modules with other classes that we’ll use, see below) 8. Importing modules • Modules contain additional useful functions and classes, but need to be read in: import random random_number = random.randint(0, 100) #gives a random int between 1 and 100 • You can specify a new variable name for the module: import random as rd random_number = rd.randint(0,100) • You can also import just a single function or class: from random import randint random_number = randint(0, 100) • Collection of modules is a package, a collection of packages is a library • Installing new modules, packages, and libraries--- easiest way is to use pip in the command prompt window • It may already be installed if you downloaded Anaconda, but if not, see: https://pip.pypa.io/en/stable/installation/ • Then in the command prompt: pip install nltk (or) pip3 install nltk 9. Numpy arrays and Pandas dataframes • A numpy array is an array object that can be used by importing the numpy library • Arrays are like nested lists (with any number of dimensions), but they designed for efficient matrix math import numpy as np data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] data = np.array(data) • Now try out a few methods on the array above to see what happens: .max(axis = 0) .argmax(axis = 1) .sum(axis = 0) • A pandas dataframe is basically a 2-d array but with labeled rows and columns: import pandas as pd data = {“nouns” : [16, 33, 52, 21], “verbs”: [32, 63, 27, 34], “adjectives”:[8, 14, 24, 11]} df = pd.DataFrame(data, index = [“doc1”, “doc2”, “doc3”, “doc4”]) • The columns form “Series,” which you can reference as methods: print (df.nouns) OR print (df[‘nouns’] • To refer to a row: print (df.iloc[0]) • Similar to numpy arrays, there are methods for performing math on the dataframe: print (df.mean(axis = 0) print (df.nouns.max()) …etc. 10. A few coding tips • Run your program at every step, checking the variables to make sure each step performs as expected • Use functions to organize and compartmentalize (especially when the code is more than ~10-20 lines) • Read the error messages--- they should tell you the line that caused the program to crash • Use descriptive variable names, and clear write comments (#) throughout • Note that errors quite commonly are caused by small syntax issues, with a single character missing, mistyped, or misplaced Exercise: Write a program that creates a pandas dataframe with a list of 20+ words as its rows. The list should contain some duplicate words. The columns in the dataframe should include the letter the word begins with, the letter the word ends with, the length of the word, and the number of occurrences of the word within the list. Try querying the dataframe to find the longest or shortest word, or the one with the most or fewest occurrences. Example word list: [‘cat’, ‘dog’, ‘horse’, ‘dog’, ‘pigeon’, ‘monkey’, ‘dog’, ‘snake’, ‘cat’, ‘pigeon’, ‘wolf,’ ‘triceratops’, ‘zebra’, ‘horse’, ‘dog’, ‘dog’, ‘antelope’, ‘zebra’, ‘cat, ‘dog’, ‘wolf’, ‘snake’] Tips: There are lots of ways to do this, so don’t worry if your way is the “best” at this point. Divide and conquer--- work on each part one at a time. You may use lists, sets, dictionaries, and dataframes, but not necessarily all of these depending on your strategy. Note you can convert between sets and lists and back again with set() and list() You may or may not use a dictionary, but if you want a list that is just the keys: a = dict.keys(), or just the values: a = dict.values()","libVersion":"0.5.0","langs":""}